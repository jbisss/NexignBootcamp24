# NexignBootcamp 24

**ВАЖНО**

Все сервисы запускаются и работают, предоставляя возможность пройти по полному циклу проекта - 
генерации CDR-файлов в **CDR-сервисе**, авторизация CDR-файлов в **BRT-сервисе**, тарификация
абонентов оператора "Ромашка" в **HRS-сервисе**, **Eureka-сервис** используется в качестве 
реестра всех микросервисов проекта, **API-gateway сервис** используется для предоставления единой
точки доступа к API приложения в целом, а также связи с **Security-сервисом**, предназначенным для
создания пользователей, проверки доступа к ендпоинтам для каждого пользователя (ролевая модель -
разграничение доступа для роли ***abonent***, ***manager***, ***admin***) 

В папке каждого сервиса содержится ***Dockerfile***, с помощью которого успешно собирается docker-образ (image)
сервиса 

В корне проекта содержится docker-compose.yml файл для описания согласованной сборки и запуска
всех контейнеров сервисов

**<u>К сожалению</u>** мне не удалось описать docker-compose.yml таким образом, чтобы всё успешно
собиралось, в итоге я пришёл к тому, что контейнеры с основными сервисами реализующими всю
бизнес-логику приложения (cdr, brt, hrs) не видят контейнер с Kafka 

Проект состоит из следующих сервисов:

- **CDR** сервис 
- **BRT** сервис
- **HRS** сервис
- **API-Gateway** сервис
- **Eureka** сервис
- **Security** сервис

БД - postgres
Services communication - **Kafka** Message Broker

## Services schema

API SPECIFICATION: https://app.swaggerhub.com/apis/gorovenkoiulia/CRM/1.0.0

<p align="center">
  <img src="https://raw.githubusercontent.com/jbisss/NexignBootcamp24/master/service_schema.jpg">
</p>

## CDR сервис

**port** - <u>random</u>

Данный сервис генерирует Cdr файлы с данными о звонках, номер абонента 
выбирается либо из существующих номеров абонентов оператора "Ромашка", либо генерируется 
случайный номер (как будто существующий номер, но абонента другого оператора)

Каждые 10 сгенерированных записей составляют 1 CDR файл, который сразу отправляется в Kafka
по топику, из которого этот CDR будет вычитан BRT сервисом для авторизации этого файла

### BRT сервис

**port** - <u>random</u>

Данный сервис читает из Kafka сгенерированные CDR-файлы и производит авторизацию этих файлов,
основываясь на данных об абонентам представленных в его базе данных

Авторизованные записи только с абонентами оператора "Ромашки" и их тарифами Brt отправляет в Kafka, 
откуда эти записи вычитываются Hrs-сервисом для тарификации абонентов

Также Brt получает данные о том, сколько средств необходимо списать с абонента по итогам
тарификкации в Hrs-сервисе

<p align="center">
  <img src="https://raw.githubusercontent.com/jbisss/NexignBootcamp24/master/BRT_db_schema.jpg" alt="BRT_DB_SCHEMA">
    <br>
BRT_DB_SCHEMA
</p>

### HRS сервис

**port** - <u>random</u>

Данный сервис читает из Kafka авторизованные CDR-файлы и производит тарификацию - либо по
*поминутному* тарифу, либо по *месячному* - для тарификации по каждому из тарифов описаны свои 
классы

Данные о том, сколько средств необходимо списать с каждого абонента по итогам тарификации постятся
в Kafka, откуда будут вычитаны Brt-сервисом и обработаны

<p align="center">
  <img src="https://raw.githubusercontent.com/jbisss/NexignBootcamp24/master/HRS_db_schema.jpg" alt="HRS_DB_SCHEMA">
    <br>
HRS_DB_SCHEMA
</p>

### API-Gateway сервис

**port** - <u>8765</u>

Данный сервис обеспечивает единую точку входа для REST API приложения, сервис
маршрутизирует запросы к соответствующим сервиса, а также обеспечивает авторизацию
используя **Security-сервис**

### Eureka сервис

**port** - <u>8761</u>

Реестр сервисов, в котором каждый из запускаемых сервисов регистрируется при запуске, с помощью
него сервисы могут узнавать друг о друге 

Таким образом, Brt-сервис при создании абонента запрашивает у Hrs-сервиса существует ли тариф с
тем или иным id (так как создание абонента лежит на Brt)

### Security сервис

**port** - <u>random</u>

Сервис предназначен для создания пользователей, генерации JWT токена, валидации запроса,
у которого в auth-header'е обязательно должен быть приложен JWT токен

Доступные пользователи в формате username/password:

- abonent/abonent_password
- manager/manager_password
- admin/admin_password

Для того, чтобы иметь возможность слать запросы необходимо авторизовываться по 
Bearer Token'у, который генерируется по /auth/token с телом запроса (например):

```json
{
    "name": "admin",
    "password": "admin_password"
}
```

В postman-коллекции - https://github.com/jbisss/NexignBootcamp24/blob/master/CRM.postman_collection.json - пример запроса представлен в папке security
